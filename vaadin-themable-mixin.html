<link rel="import" href="../polymer/lib/elements/dom-module.html">

<script>
  window.Vaadin = window.Vaadin || {};

  /**
   * @polymerMixin
   */
  Vaadin.ThemableMixin = superClass => class VaadinThemableMixin extends superClass {
    static get template() {
      if (super.template && !this.hasOwnProperty('_memoizedThemableMixinTemplate')) {
        this._memoizedThemableMixinTemplate = super.template.cloneNode(true);

        const modules = Polymer.DomModule.prototype.modules;
        let hasThemes = false;
        const defaultModuleName = this.is + '-default-theme';

        Object.keys(modules).forEach(moduleName => {
          if (moduleName !== defaultModuleName) {
            const themeFor = modules[moduleName].getAttribute('theme-for');
            if (themeFor) {
              themeFor.split(' ').forEach(themeForToken => {
                if (new RegExp('^' + themeForToken.split('*').join('.*') + '$').test(this.is)) {
                  hasThemes = true;
                  this.includeStyle(moduleName);
                }
              });
            }
          }
        });

        if (!hasThemes) {
          // No theme modules found, include the default module
          this.includeStyle(defaultModuleName);
        }
      }
      return this._memoizedThemableMixinTemplate;
    }

    ready() {
      super.ready();
      this.updateStyles();
    }

    updateStyles() {
      super.updateStyles();

      // On updateStyles we recompute the theme attribute based on custom CSS properties
      // theme attribute and --theme property can contain multiple themes separated by space
      const currentThemes = (this.getAttribute('theme') || '').split(/ +/);
      const computedThemes = this._getComputedStyle(`--theme`).split(/ +/);

      // We only update theme attribute if the current theme does not includes any of the computed values
      // console.log(this.localName,currentThemes, computedThemes)
      computedThemes.forEach((theme) => currentThemes.indexOf(theme) < 0 && currentThemes.push(theme));
      this.setAttribute('theme', currentThemes.join(' ').trim());

      // We update styles in cascade, but only in themable elements
      Array.from(this.root.querySelectorAll('*')).forEach(e => e.constructor._memoizedThemableMixinTemplate && e.updateStyles());
    }

    _getComputedStyle(name) {
      return (window.ShadyCSS ? window.ShadyCSS.getComputedStyleValue(this, name) : getComputedStyle(this).getPropertyValue(name))
        // When getting the computed value, we need to remove wrapping spaces and quotes.
        .trim().replace(/^['"](.*)["']$/, '$1');
    }

    static includeStyle(moduleName) {
      const styleEl = document.createElement('style');
      styleEl.setAttribute('include', moduleName);
      this._memoizedThemableMixinTemplate.content.appendChild(styleEl);
    }

  };
</script>
